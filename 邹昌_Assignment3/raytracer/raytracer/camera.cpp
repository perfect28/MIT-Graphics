
#include "camera.h"
#include "matrix.h"
#include <GL/glut.h>

Camera::Camera()
{
}

Camera::~Camera()
{
}

OrthographicCamera::OrthographicCamera(Vec3f center, Vec3f dir, Vec3f up, float size)
{
	this->center = center;
	this->dir = dir;
	this->dir.Normalize();
	this->up = up;
	this->up.Normalize();
	this->size = size;
	Vec3f::Cross3(this->hor, this->dir, this->up);
	this->hor.Normalize();
}

OrthographicCamera::~OrthographicCamera()
{
}

/*
The first is used to generate rays for each screen-space coordinate,
described as a Vec2f. The direction of the rays generated by an orthographic
camera is always the same, but the origin varies. The getTMin() method
will be useful when tracing rays through the scene. For an orthographic
camera, rays always start at infinity, so tmin will be a large negative
value. However, in the next assignment you will implement a perspective
camera and the value of tmin will be zero to correctly clip objects behind
the viewpoint.
*/


/*
(0,0) -> (1,1)
center - (size*up)/2 - (size*horizontal)/2  ->  center + (size*up)/2 + (size*horizontal)/2

Ray Generation:
Origin = center + (x-0.5)*size*horizontal + (y-0.5)*size*up;
Direction is constant
*/
Ray OrthographicCamera::generateRay(Vec2f point)
{
	float x = point.x();
	float y = point.y();
	Vec3f ori = center + (x - 0.5)*size*hor + (y - 0.5)*size*up;
	Ray *ray = new Ray(ori, dir);
	return *ray;
}

float OrthographicCamera::getTMin() const
{
	float min = (numeric_limits<float>::min)();
	return min;
}

/*
Hint: In class, we often talk about a "virtual screen" in space. You can calculate 
the location and extents of this "virtual screen" using some simple trigonometry. 
You can then interpolate over points on the virtual screen in the same way you 
interpolated over points on the screen for the orthographic camera. Direction vectors 
can then be calculated by subtracting the camera center point from the screen 
point. Don't forget to normalize! In contrast, if you interpolate over 
the camera angle to obtain your direction vectors, your scene will look 
distorted - especially for large camera angles, which will give the appearance 
of a fisheye lens.

Note: the distance to the image plane and the size of the image plane are unnecessary. Why?
*/

PerspectiveCamera::PerspectiveCamera(Vec3f cer, Vec3f &direction, Vec3f &up, float angle)
{
	this->center = cer;
	direction.Normalize();
	this->dir = direction;
	up.Normalize();
	this->up = up;
	Vec3f::Cross3(this->hor, this->dir, this->up);
	this->hor.Normalize();
	this->angle = angle;
	float theta = angle / 2.0f;
	this->dis = 1.0f / (sin(theta) * 2.0f);
}

PerspectiveCamera::~PerspectiveCamera()
{
}

Ray PerspectiveCamera::generateRay(Vec2f point)
{
	float x = point.x();
	float y = point.y();
	Vec3f ori = center + (x - 0.5f)*hor + (y - 0.5f)*up + dis*dir;
	Vec3f now_dir = ori - center;
	now_dir.Normalize();
	return Ray(ori, now_dir);
}

float PerspectiveCamera::getTMin() const
{
	float min = (numeric_limits<float>::min)();
	return min;
}


// ====================================================================
// Here are the prototypes for five pure virtual functions for
// initializing, placing, dollying, trucking, and rotating an
// OpenGL camera.  These should be added to the Camera class and
// each of its subclasses
// ====================================================================


void OrthographicCamera::glInit(int w, int h)
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	//glOrtho是创建一个正交平行的视景体
	//参数：glOrtho(左，右，下，上，近，远)
	if (w > h)
	glOrtho(-size/2.0, size/2.0, -size*(float)h/(float)w/2.0, size*(float)h/(float)w/2.0, 0.5, 40.0);
	else
	glOrtho(-size*(float)w/(float)h/2.0, size*(float)w/(float)h/2.0, -size/2.0, size/2.0, 0.5, 40.0);
}

// ====================================================================
// Place an orthographic camera within an OpenGL scene
// ====================================================================

void OrthographicCamera::glPlaceCamera(void)
{
	/*
	该函数定义一个视图矩阵，并与当前矩阵相乘。
	第一组eyex, eyey,eyez 相机在世界坐标的位置
	第二组centerx,centery,centerz 相机镜头对准的物体在世界坐标的位置
	第三组upx,upy,upz 相机向上的方向在世界坐标中的方向
	*/
	gluLookAt(center.x(), center.y(), center.z(),
	center.x()+dir.x(), center.y()+dir.y(), center.z()+dir.z(),
	up.x(), up.y(), up.z());
}

// ====================================================================
// dollyCamera, truckCamera, and RotateCamera
//
// Asumptions:
//  - up is really up (i.e., it hasn't been changed
//    to point to "screen up")
//  - up and direction are normalized
// Special considerations:
//  - If your constructor precomputes any vectors for
//    use in 'generateRay', you will likely to recompute those
//    values at athe end of the these three routines
// ====================================================================

// ====================================================================
// dollyCamera: Move camera along the direction vector
// ====================================================================

void OrthographicCamera::dollyCamera(float dist)
{
	center += dir*dist;
	// 除了相机中心，其他变量并无变化
	// ===========================================
	// ASSIGNMENT 3: Fix any other affected values
	// ===========================================
}

// ====================================================================
// truckCamera: Translate camera perpendicular to the dir vector
// ====================================================================

void OrthographicCamera::truckCamera(float dx, float dy)
{
	Vec3f horizontal;
	Vec3f::Cross3(horizontal, dir, up);
	horizontal.Normalize();

	Vec3f screenUp;
	Vec3f::Cross3(screenUp, horizontal, dir);

	center += horizontal*dx + screenUp*dy;

	// ===========================================
	// ASSIGNMENT 3: Fix any other affected values
	// ===========================================


}

// ====================================================================
// rotateCamera: Rotate around the up and horizontal vectors
// ====================================================================

void OrthographicCamera::rotateCamera(float rx, float ry)
{
	Vec3f horizontal;
	Vec3f::Cross3(horizontal, dir, up);
	horizontal.Normalize();

	// Don't let the model flip upside-down (There is a singularity
	// at the poles when 'up' and 'dir' are aligned)
	float tiltAngle = acos(up.Dot3(dir));
	if (tiltAngle-ry > 3.13)
	ry = tiltAngle - 3.13;
	else if (tiltAngle-ry < 0.01)
	ry = tiltAngle - 0.01;

	Matrix rotMat = Matrix::MakeAxisRotation(up, rx);
	rotMat *= Matrix::MakeAxisRotation(horizontal, ry);

	rotMat.Transform(center);
	rotMat.TransformDirection(dir);

	// ===========================================
	// ASSIGNMENT 3: Fix any other affected values
	// ===========================================

}

// ====================================================================
// ====================================================================

// ====================================================================
// Create a perspective camera with the appropriate dimensions that
// crops or stretches in the x-dimension as necessary
// ====================================================================

void PerspectiveCamera::glInit(int w, int h)
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	/*
	GLdouble fovy, //角度
	GLdouble aspect,//视景体的宽高比
	GLdouble zNear,//沿z轴方向的两裁面之间的距离的近处
	GLdouble zFar //沿z轴方向的两裁面之间的距离的远处
	*/
	gluPerspective(angle*180.0/3.14159, (float)w/float(h), 0.5, 40.0);
}

// ====================================================================
// Place a perspective camera within an OpenGL scene
// ====================================================================

void PerspectiveCamera::glPlaceCamera(void)
{
	gluLookAt(center.x(), center.y(), center.z(),
	center.x()+dir.x(), center.y()+dir.y(), center.z()+dir.z(),
	up.x(), up.y(), up.z());
}

// ====================================================================
// dollyCamera, truckCamera, and RotateCamera
//
// Asumptions:
//  - up is really up (i.e., it hasn't been changed
//    to point to "screen up")
//  - up and direction are normalized
// Special considerations:
//  - If your constructor precomputes any vectors for
//    use in 'generateRay', you will likely to recompute those
//    values at athe end of the these three routines
// ====================================================================

// ====================================================================
// dollyCamera: Move camera along the direction vector
// ====================================================================

void PerspectiveCamera::dollyCamera(float dist)
{
	center += dir*dist;

	// ===========================================
	// ASSIGNMENT 3: Fix any other affected values
	// ===========================================


}

// ====================================================================
// truckCamera: Translate camera perpendicular to the direction vector
// ====================================================================

void PerspectiveCamera::truckCamera(float dx, float dy)
{
	Vec3f horizontal;
	Vec3f::Cross3(horizontal, dir, up);
	horizontal.Normalize();

	Vec3f screenUp;
	Vec3f::Cross3(screenUp, horizontal, dir);

	center += horizontal*dx + screenUp*dy;

	// ===========================================
	// ASSIGNMENT 3: Fix any other affected values
	// ===========================================


}

// ====================================================================
// rotateCamera: Rotate around the up and horizontal vectors
// ====================================================================

void PerspectiveCamera::rotateCamera(float rx, float ry)
{
	Vec3f horizontal;
	Vec3f::Cross3(horizontal, dir, up);
	horizontal.Normalize();

	// Don't let the model flip upside-down (There is a singularity
	// at the poles when 'up' and 'direction' are aligned)
	float tiltAngle = acos(up.Dot3(dir));
	if (tiltAngle-ry > 3.13)
	ry = tiltAngle - 3.13;
	else if (tiltAngle-ry < 0.01)
	ry = tiltAngle - 0.01;

	Matrix rotMat = Matrix::MakeAxisRotation(up, rx);
	rotMat *= Matrix::MakeAxisRotation(horizontal, ry);

	rotMat.Transform(center);
	rotMat.TransformDirection(dir);
	dir.Normalize();

	// ===========================================
	// ASSIGNMENT 3: Fix any other affected values
	// ===========================================
}

// ====================================================================
// ====================================================================


/*
Use the left mouse button to rotate the camera around the center of the scene,
the middle mouse button to translate the scene center (truck), and the right 
mouse button to move the camera closer to or further from the scene (dolly). 
To prevent weird rotations of the camera, it is necessary to store the original 
up vector of the camera and define a new "screen up" vector that is the normalized 
orthogonal up vector for the current direction vector. You can test your implementation 
at this point. In the GLCanvas::display() function is a call to the provided drawAxes() 
function, which will allow you to debug your camera implementation.

Once you start working on your Object3D paint methods (described below), 
you should comment out the call to drawAxes. Once your paint methods are complete, 
verify that your camera manipulation code is correct by moving the camera, rendering 
the scene & then comparing the pre-visualization to the raytraced result.
*/