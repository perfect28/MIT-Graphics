
#include "camera.h"

Camera::Camera()
{
}

Camera::~Camera()
{
}

OrthographicCamera::OrthographicCamera(Vec3f center, Vec3f dir, Vec3f up, float size)
{
	this->center = center;
	this->dir = dir;
	this->dir.Normalize();
	this->up = up;
	this->up.Normalize();
	this->size = size;
	Vec3f::Cross3(this->hor, this->dir, this->up);
	this->hor.Normalize();
}

OrthographicCamera::~OrthographicCamera()
{
}

/*
The first is used to generate rays for each screen-space coordinate,
described as a Vec2f. The direction of the rays generated by an orthographic
camera is always the same, but the origin varies. The getTMin() method
will be useful when tracing rays through the scene. For an orthographic
camera, rays always start at infinity, so tmin will be a large negative
value. However, in the next assignment you will implement a perspective
camera and the value of tmin will be zero to correctly clip objects behind
the viewpoint.
*/


/*
(0,0) -> (1,1)
center - (size*up)/2 - (size*horizontal)/2  ->  center + (size*up)/2 + (size*horizontal)/2

Ray Generation:
Origin = center + (x-0.5)*size*horizontal + (y-0.5)*size*up;
Direction is constant
*/
Ray OrthographicCamera::generateRay(Vec2f point)
{
	float x = point.x();
	float y = point.y();
	Vec3f ori = center + (x - 0.5)*size*hor + (y - 0.5)*size*up;
	Ray *ray = new Ray(ori, dir);
	return *ray;
}

float OrthographicCamera::getTMin() const
{
	float min = (numeric_limits<float>::min)();
	return min;
}

/*
Hint: In class, we often talk about a "virtual screen" in space. You can calculate 
the location and extents of this "virtual screen" using some simple trigonometry. 
You can then interpolate over points on the virtual screen in the same way you 
interpolated over points on the screen for the orthographic camera. Direction vectors 
can then be calculated by subtracting the camera center point from the screen 
point. Don't forget to normalize! In contrast, if you interpolate over 
the camera angle to obtain your direction vectors, your scene will look 
distorted - especially for large camera angles, which will give the appearance 
of a fisheye lens.

Note: the distance to the image plane and the size of the image plane are unnecessary. Why?
*/

PerspectiveCamera::PerspectiveCamera(Vec3f cer, Vec3f &direction, Vec3f &up, float angle)
{
	this->center = cer;
	direction.Normalize();
	this->dir = direction;
	up.Normalize();
	this->up = up;
	Vec3f::Cross3(this->hor, this->dir, this->up);
	this->hor.Normalize();
	this->angle = angle;
	float theta = angle / 2.0f;
	this->dis = 1.0f / (sin(theta) * 2.0f);
}

PerspectiveCamera::~PerspectiveCamera()
{
}

Ray PerspectiveCamera::generateRay(Vec2f point)
{
	float x = point.x();
	float y = point.y();
	Vec3f ori = center + (x - 0.5f)*hor + (y - 0.5f)*up + dis*dir;
	Vec3f now_dir = ori - center;
	now_dir.Normalize();
	return Ray(ori, now_dir);
}

float PerspectiveCamera::getTMin() const
{
	float min = (numeric_limits<float>::min)();
	return min;
}